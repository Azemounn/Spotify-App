import axios from 'axios';

const BASE_URL = 'https://api.spotify.com/v1';
let accessToken = '';

export const setAccessToken = (token) => {
  accessToken = token;
  axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
};

const getHeaders = () => ({
  headers: {
    Authorization: `Bearer ${accessToken}`
  }
});

const handleError = (error) => {
  if (error.response) {
    console.error(`Error: ${error.response.status} - ${error.response.statusText}`);
    console.error(`Details: ${JSON.stringify(error.response.data)}`);
  } else {
    console.error(`Error: ${error.message}`);
  }
  throw error;  // Rethrow the error to handle it in the calling function if needed
};

export const getUserProfile = async () => {
  try {
    const response = await axios.get(`${BASE_URL}/me`, getHeaders());
    return response.data;
  } catch (error) {
    handleError(error);
  }
};

export const getUserTopTracks = async (timeRange = 'medium_term') => {
  try {
    const response = await axios.get(`${BASE_URL}/me/top/tracks?limit=50&time_range=${timeRange}`, getHeaders());
    return response.data;
  } catch (error) {
    handleError(error);
  }
};

export const getUserTopGenres = async () => {
  try {
    const response = await axios.get(`${BASE_URL}/me/top/artists?limit=50&time_range=medium_term`, getHeaders());
    const genres = response.data.items.flatMap(artist => artist.genres);
    return Array.from(new Set(genres));
  } catch (error) {
    handleError(error);
  }
};

export const getPersonalizedRecommendations = async (seedTracks, limit = 50) => {
  const params = new URLSearchParams({
    seed_tracks: seedTracks.slice(0, 5).join(','), // Ensure only up to 5 seed tracks
    limit: limit.toString(),
  });

  try {
    const response = await axios.get(`${BASE_URL}/recommendations?${params.toString()}`, getHeaders());
    return response.data.tracks;
  } catch (error) {
    handleError(error);
  }
};

export const createPlaylist = async (userId, name, trackUris) => {
  try {
    // Validate track URIs before proceeding
    const validTrackUris = trackUris.filter(uri => /^spotify:track:[a-zA-Z0-9]+$/.test(uri));
    if (validTrackUris.length !== trackUris.length) {
      console.error('Some track URIs were invalid:', trackUris.filter(uri => !/^spotify:track:[a-zA-Z0-9]+$/.test(uri)));
    }

    const playlistResponse = await axios.post(`${BASE_URL}/users/${userId}/playlists`, {
      name,
      description: 'Generated by Playlist Gen',
      public: false
    }, getHeaders());

    const playlistId = playlistResponse.data.id;
    console.log(`Playlist created with ID: ${playlistId}`);

    const chunkSize = 100;
    for (let i = 0; i < validTrackUris.length; i += chunkSize) {
      const chunk = validTrackUris.slice(i, i + chunkSize);
      await axios.post(`${BASE_URL}/playlists/${playlistId}/tracks`, {
        uris: chunk
      }, getHeaders());
      console.log(`Added ${chunk.length} tracks to playlist: ${playlistId}`);
    }

    return playlistResponse.data;
  } catch (error) {
    handleError(error);
  }
};

export const uploadPlaylistImage = async (playlistId, imageFile) => {
  const imageBlob = await new Promise((resolve) => {
    const reader = new FileReader();
    reader.onloadend = () => {
      resolve(reader.result.split(',')[1]);
    };
    reader.readAsDataURL(imageFile);
  });

  try {
    await axios.put(`${BASE_URL}/playlists/${playlistId}/images`, imageBlob, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'image/jpeg'
      }
    });
    console.log(`Playlist image uploaded for playlist: ${playlistId}`);
  } catch (error) {
    handleError(error);
  }
};

export const fetchLatestReleases = async () => {
  try {
    const response = await axios.get(`${BASE_URL}/browse/new-releases?limit=50`, getHeaders());
    return response.data.albums.items;
  } catch (error) {
    handleError(error);
  }
};

// Export BASE_URL and getHeaders
export { BASE_URL, getHeaders };
